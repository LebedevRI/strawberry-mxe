diff -ruN glib-2.56.1.orig/configure.ac glib-2.56.1/configure.ac
--- glib-2.56.1.orig/configure.ac	2018-04-07 04:35:35.000000000 +0200
+++ glib-2.56.1/configure.ac	2018-07-01 13:29:14.481444150 +0200
@@ -486,6 +486,8 @@
 dnl when using libtool 2.x create libtool early, because it's used in configure
 m4_ifdef([LT_OUTPUT], [LT_OUTPUT])
 
+# Make sure STDC_HEADERS is set for AC_CHECK_ALIGNOF
+AS_IF([false], [AC_CHECK_HEADER([stdint.h])])
 
 AS_IF([test "$glib_native_win32" = "yes"], [
   if test x$enable_static = xyes -a x$enable_shared = xyes; then
@@ -1698,10 +1700,17 @@
 dnl ** Check for inotify (GIO) **
 dnl *****************************
 inotify_support=no
+ AC_ARG_ENABLE(inotify,
+               AC_HELP_STRING([--disable-inotify],
+                              [build without inotify support]))
+
+ if test "x$enable_inotify" != "xno"; then
+
 AC_CHECK_HEADERS([sys/inotify.h],
 [
   AC_CHECK_FUNCS(inotify_init1, [inotify_support=yes], [inotify_support=no])
 ])
+fi
 
 AM_CONDITIONAL(HAVE_INOTIFY, [test "$inotify_support" = "yes"])
 
diff -ruN glib-2.56.1.orig/gio/gdbusaddress.c glib-2.56.1/gio/gdbusaddress.c
--- glib-2.56.1.orig/gio/gdbusaddress.c	2018-02-06 16:44:20.000000000 +0100
+++ glib-2.56.1/gio/gdbusaddress.c	2018-07-01 13:48:22.634262578 +0200
@@ -1406,6 +1406,7 @@
 __declspec(dllexport) void CALLBACK
 g_win32_run_session_bus (HWND hwnd, HINSTANCE hinst, char *cmdline, int nCmdShow)
 {
+/*
   GDBusDaemon *daemon;
   GMainLoop *loop;
   const char *address;
@@ -1438,6 +1439,7 @@
 
   g_main_loop_unref (loop);
   g_object_unref (daemon);
+*/
 }
 
 static gchar *
diff -ruN glib-2.56.1.orig/gio/giomodule.c glib-2.56.1/gio/giomodule.c
--- glib-2.56.1.orig/gio/giomodule.c	2018-04-07 04:10:22.000000000 +0200
+++ glib-2.56.1/gio/giomodule.c	2018-07-01 13:50:24.597505823 +0200
@@ -968,14 +968,12 @@
 
 static HMODULE gio_dll = NULL;
 
-#ifdef DLL_EXPORT
-
-BOOL WINAPI DllMain (HINSTANCE hinstDLL,
+BOOL WINAPI gio_DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
+gio_DllMain (HINSTANCE hinstDLL,
 	 DWORD     fdwReason,
 	 LPVOID    lpvReserved)
 {
@@ -985,8 +983,6 @@
   return TRUE;
 }
 
-#endif
-
 void *
 _g_io_win32_get_module (void)
 {
diff -ruN glib-2.56.1.orig/gio-2.0.pc.in glib-2.56.1/gio-2.0.pc.in
--- glib-2.56.1.orig/gio-2.0.pc.in	2017-02-13 16:53:27.000000000 +0100
+++ glib-2.56.1/gio-2.0.pc.in	2018-07-01 13:29:57.585171236 +0200
@@ -13,6 +13,6 @@
 Version: @VERSION@
 Requires: glib-2.0 gobject-2.0
 Requires.private: gmodule-no-export-2.0
-Libs: -L${libdir} -lgio-2.0
+Libs: -L${libdir} -lgio-2.0 -ldnsapi -liphlpapi
 Libs.private: @ZLIB_LIBS@ @NETWORK_LIBS@ @SELINUX_LIBS@ @COCOA_LIBS@ @CARBON_LIBS@ @LIBMOUNT_LIBS@
 Cflags:
diff -ruN glib-2.56.1.orig/glib/glib-init.c glib-2.56.1/glib/glib-init.c
--- glib-2.56.1.orig/glib/glib-init.c	2018-01-10 05:42:06.000000000 +0100
+++ glib-2.56.1/glib/glib-init.c	2018-07-01 13:25:37.646818057 +0200
@@ -275,14 +275,14 @@
 
 #if defined (G_OS_WIN32)
 
-BOOL WINAPI DllMain (HINSTANCE hinstDLL,
+BOOL WINAPI glib_DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
 HMODULE glib_dll;
 
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL,
+glib_DllMain (HINSTANCE hinstDLL,
          DWORD     fdwReason,
          LPVOID    lpvReserved)
 {
diff -ruN glib-2.56.1.orig/glib/gmain.c glib-2.56.1/glib/gmain.c
--- glib-2.56.1.orig/glib/gmain.c	2018-04-07 04:10:22.000000000 +0200
+++ glib-2.56.1/glib/gmain.c	2018-07-01 13:34:26.587469851 +0200
@@ -2717,12 +2717,15 @@
  * So for now we calculate (usec_per_sec / ticks_per_sec) and use floating point
  */
 static gdouble g_monotonic_usec_per_tick = 0;
+static gboolean g_win32_clock_is_initialized;
 
 void
 g_clock_win32_init (void)
 {
   LARGE_INTEGER freq;
 
+  g_win32_clock_is_initialized = TRUE;
+
   if (!QueryPerformanceFrequency (&freq) || freq.QuadPart == 0)
     {
       /* The documentation says that this should never happen */
@@ -2736,6 +2739,8 @@
 gint64
 g_get_monotonic_time (void)
 {
+  if (!g_win32_clock_is_initialized)
+    g_clock_win32_init ();
   if (G_LIKELY (g_monotonic_usec_per_tick != 0))
     {
       LARGE_INTEGER ticks;
diff -ruN glib-2.56.1.orig/glib/gthread-win32.c glib-2.56.1/glib/gthread-win32.c
--- glib-2.56.1.orig/glib/gthread-win32.c	2017-07-14 01:03:39.000000000 +0200
+++ glib-2.56.1/glib/gthread-win32.c	2018-07-01 13:46:25.350990365 +0200
@@ -116,18 +116,28 @@
   void     (__stdcall * WakeConditionVariable)       (gpointer cond);
 } GThreadImplVtable;
 
+/* Needed for static builds where DllMain initializer doesn't get called */
+static gboolean g_threads_is_initialized;
+G_GNUC_INTERNAL void g_thread_win32_init (void);
+
 static GThreadImplVtable g_thread_impl_vtable;
 
 /* {{{1 GMutex */
 void
 g_mutex_init (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   g_thread_impl_vtable.InitializeSRWLock (mutex);
 }
 
 void
 g_mutex_clear (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (mutex);
 }
@@ -141,12 +151,17 @@
 gboolean
 g_mutex_trylock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (mutex);
 }
 
 void
 g_mutex_unlock (GMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.ReleaseSRWLockExclusive (mutex);
 }
 
@@ -156,6 +171,8 @@
 g_rec_mutex_impl_new (void)
 {
   CRITICAL_SECTION *cs;
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
 
   cs = g_slice_new (CRITICAL_SECTION);
   InitializeCriticalSection (cs);
@@ -167,6 +184,10 @@
 g_rec_mutex_impl_free (CRITICAL_SECTION *cs)
 {
   DeleteCriticalSection (cs);
+
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   g_slice_free (CRITICAL_SECTION, cs);
 }
 
@@ -175,6 +196,9 @@
 {
   CRITICAL_SECTION *impl = mutex->p;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   if G_UNLIKELY (mutex->p == NULL)
     {
       impl = g_rec_mutex_impl_new ();
@@ -189,30 +213,40 @@
 void
 g_rec_mutex_init (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   mutex->p = g_rec_mutex_impl_new ();
 }
 
 void
 g_rec_mutex_clear (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_rec_mutex_impl_free (mutex->p);
 }
 
 void
 g_rec_mutex_lock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   EnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
 void
 g_rec_mutex_unlock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   LeaveCriticalSection (mutex->p);
 }
 
 gboolean
 g_rec_mutex_trylock (GRecMutex *mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   return TryEnterCriticalSection (g_rec_mutex_get_impl (mutex));
 }
 
@@ -221,12 +255,16 @@
 void
 g_rw_lock_init (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.InitializeSRWLock (lock);
 }
 
 void
 g_rw_lock_clear (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   if (g_thread_impl_vtable.DeleteSRWLock != NULL)
     g_thread_impl_vtable.DeleteSRWLock (lock);
 }
@@ -234,36 +272,48 @@
 void
 g_rw_lock_writer_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.AcquireSRWLockExclusive (lock);
 }
 
 gboolean
 g_rw_lock_writer_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   return g_thread_impl_vtable.TryAcquireSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_writer_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.ReleaseSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_reader_lock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.AcquireSRWLockShared (lock);
 }
 
 gboolean
 g_rw_lock_reader_trylock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   return g_thread_impl_vtable.TryAcquireSRWLockShared (lock);
 }
 
 void
 g_rw_lock_reader_unlock (GRWLock *lock)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.ReleaseSRWLockShared (lock);
 }
 
@@ -271,12 +321,16 @@
 void
 g_cond_init (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.InitializeConditionVariable (cond);
 }
 
 void
 g_cond_clear (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   if (g_thread_impl_vtable.DeleteConditionVariable)
     g_thread_impl_vtable.DeleteConditionVariable (cond);
 }
@@ -284,12 +338,16 @@
 void
 g_cond_signal (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.WakeConditionVariable (cond);
 }
 
 void
 g_cond_broadcast (GCond *cond)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.WakeAllConditionVariable (cond);
 }
 
@@ -297,6 +355,8 @@
 g_cond_wait (GCond  *cond,
              GMutex *entered_mutex)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   g_thread_impl_vtable.SleepConditionVariableSRW (cond, entered_mutex, INFINITE, 0);
 }
 
@@ -307,6 +367,9 @@
 {
   gint64 span;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   span = end_time - g_get_monotonic_time ();
 
   if G_UNLIKELY (span < 0)
@@ -339,6 +402,8 @@
 
   if G_UNLIKELY (impl == 0)
     {
+      if (!g_threads_is_initialized)
+        g_thread_win32_init();
       EnterCriticalSection (&g_private_lock);
       impl = (DWORD) key->p;
       if (impl == 0)
@@ -432,6 +497,9 @@
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   win32_check_for_error (CloseHandle (wt->handle));
   g_slice_free (GThreadWin32, wt);
 }
@@ -439,6 +507,8 @@
 void
 g_system_thread_exit (void)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   _endthreadex (0);
 }
 
@@ -447,6 +517,9 @@
 {
   GThreadWin32 *self = data;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   self->proxy (self);
 
   g_system_thread_exit ();
@@ -464,6 +537,9 @@
   GThreadWin32 *thread;
   guint ignore;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   thread = g_slice_new0 (GThreadWin32);
   thread->proxy = func;
 
@@ -493,6 +569,9 @@
 {
   GThreadWin32 *wt = (GThreadWin32 *) thread;
 
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
+
   win32_check_for_error (WAIT_FAILED != WaitForSingleObject (wt->handle, INFINITE));
 }
 
@@ -1041,6 +1120,8 @@
 void
 g_thread_win32_init (void)
 {
+  if (!g_threads_is_initialized)
+    g_thread_win32_init();
   if (!g_thread_lookup_native_funcs ())
     g_thread_xp_init ();
 
diff -ruN glib-2.56.1.orig/glib-2.0.pc.in glib-2.56.1/glib-2.0.pc.in
--- glib-2.56.1.orig/glib-2.0.pc.in	2016-10-22 07:17:22.000000000 +0200
+++ glib-2.56.1/glib-2.0.pc.in	2018-07-01 13:20:46.236666861 +0200
@@ -3,9 +3,9 @@
 libdir=@libdir@
 includedir=@includedir@
 
-glib_genmarshal=glib-genmarshal
-gobject_query=gobject-query
-glib_mkenums=glib-mkenums
+glib_genmarshal=@bindir@/glib-genmarshal
+gobject_query=@bindir@/gobject-query
+glib_mkenums=@bindir@/glib-mkenums
 
 Name: GLib
 Description: C Utility Library
diff -ruN glib-2.56.1.orig/gobject/gtype.c glib-2.56.1/gobject/gtype.c
--- glib-2.56.1.orig/gobject/gtype.c	2018-01-08 22:34:19.000000000 +0100
+++ glib-2.56.1/gobject/gtype.c	2018-07-01 13:26:37.090441281 +0200
@@ -4451,7 +4451,7 @@
   _g_signal_init ();
 }
 
-#if defined (G_OS_WIN32)
+#if 0
 
 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
diff -ruN glib-2.56.1.orig/m4macros/glib-gettext.m4 glib-2.56.1/m4macros/glib-gettext.m4
--- glib-2.56.1.orig/m4macros/glib-gettext.m4	2018-01-08 22:34:19.000000000 +0100
+++ glib-2.56.1/m4macros/glib-gettext.m4	2018-07-01 13:49:09.605971119 +0200
@@ -39,8 +39,8 @@
 dnl try to pull in the installed version of these macros
 dnl when running aclocal in the glib directory.
 dnl
-m4_copy([AC_DEFUN],[glib_DEFUN])
-m4_copy([AC_REQUIRE],[glib_REQUIRE])
+m4_copy_force([AC_DEFUN],[glib_DEFUN])
+m4_copy_force([AC_REQUIRE],[glib_REQUIRE])
 dnl
 dnl At the end, if we're not within glib, we'll define the public
 dnl definitions in terms of our private definitions.
