This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jonas Kvinge <jonas@jkvinge.net>
Date: Sat, 9 Nov 2019 00:33:37 +0100
Subject: [PATCH 1/1] Build fixes


diff --git a/pe-parser-library/CMakeLists.txt b/pe-parser-library/CMakeLists.txt
index 1111111..2222222 100644
--- a/pe-parser-library/CMakeLists.txt
+++ b/pe-parser-library/CMakeLists.txt
@@ -1,15 +1,6 @@
 cmake_minimum_required(VERSION 3.7)
 project(pe-parser-library)
 
-set(UNICODE_LIBRARY "any" CACHE STRING "Select a unicode library")
-set_property(CACHE UNICODE_LIBRARY PROPERTY STRINGS "any" "icu" "codecvt")
-
-# This variable is used twice so setting once at the top here to prevent
-# the chance they get out of sync.
-# This is the minimum "required" version but there's a good chance early
-# versions of ICU support the simple functionality needed by this project.
-set(ICU_MINIMUM_REQUIRED 55.0)
-
 # List all files explicitly; this will make IDEs happy (i.e. QtCreator, CLion, ...)
 list(APPEND PEPARSERLIB_SOURCEFILES
   include/parser-library/parse.h
@@ -20,57 +11,9 @@ list(APPEND PEPARSERLIB_SOURCEFILES
   src/parse.cpp
 )
 
-# Check for codecvt support. Likely the proper way to do this would be to
-# use CMake system inspection via methods like "try_compile" to determine
-# if the "#include <codecvt>" directive compiles successfully.
-if (MSVC)
-  if (MSVC_VERSION LESS 1900)
-    set(CODECVT_SUPPORTED OFF)
-  else ()
-    set(CODECVT_SUPPORTED ON)
-  endif ()
-elseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
-  if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS "5.0")
-    set(CODECVT_SUPPORTED OFF)
-  else ()
-    set(CODECVT_SUPPORTED ON)
-  endif ()
-else ()
-  find_path(CODECVT_INCLUDE_DIR NAMES "codecvt")
-  if (CODECVT_INCLUDE_DIR)
-    set(CODECVT_SUPPORTED OFF)
-  else ()
-    set(CODECVT_SUPPORTED ON)
-  endif ()
-endif ()
-
-if(${UNICODE_LIBRARY} MATCHES "icu")
-  find_package(ICU ${ICU_MINIMUM_REQUIRED} COMPONENTS uc REQUIRED)
-  add_definitions(-DUSE_ICU4C)
-  list(APPEND PEPARSERLIB_SOURCEFILES src/unicode_icu.cpp)
-elseif(${UNICODE_LIBRARY} MATCHES "codecvt")
-  if(NOT CODECVT_SUPPORTED)
-    message(SEND_ERROR "codecvt header not found")
-  endif()
-  list(APPEND PEPARSERLIB_SOURCEFILES src/unicode_codecvt.cpp)
-else()
-  find_package(ICU ${ICU_MINIMUM_REQUIRED} COMPONENTS uc)
-  if(ICU_FOUND)
-    add_definitions(-DUSE_ICU4C)
-    list(APPEND PEPARSERLIB_SOURCEFILES src/unicode_icu.cpp)
-  elseif(CODECVT_SUPPORTED)
-    list(APPEND PEPARSERLIB_SOURCEFILES src/unicode_codecvt.cpp)
-  else()
-    message(SEND_ERROR "unable to find codecvt header or ICU library (hint: try installing libicu-dev)")
-  endif(ICU_FOUND)
-endif()
-
 add_library(${PROJECT_NAME} ${PEPARSERLIB_SOURCEFILES})
 target_include_directories(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)
 target_compile_options(${PROJECT_NAME} PRIVATE ${GLOBAL_CXXFLAGS})
-if(ICU_FOUND)
-  target_link_libraries(${PROJECT_NAME} ICU::uc)
-endif()
 
 install(TARGETS ${PROJECT_NAME}
   RUNTIME DESTINATION "bin"
diff --git a/pe-parser-library/cmake/peparse-config.cmake b/pe-parser-library/cmake/peparse-config.cmake
index 1111111..2222222 100644
--- a/pe-parser-library/cmake/peparse-config.cmake
+++ b/pe-parser-library/cmake/peparse-config.cmake
@@ -1,5 +1,5 @@
-find_path(PEPARSE_INCLUDE_DIR $<SHELL_PATH:"parser-library/parse.h">)
-find_library(PEPARSE_LIBRARIES NAMES "libpe-parser-library" "pe-parser-library")
+find_path(PEPARSE_INCLUDE_DIR "parser-library/parse.h")
+find_library(PEPARSE_LIBRARIES NAMES "libpe-parser-library")
 
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(peparse DEFAULT_MSG PEPARSE_INCLUDE_DIR PEPARSE_LIBRARIES)
diff --git a/pe-parser-library/include/parser-library/parse.h b/pe-parser-library/include/parser-library/parse.h
index 1111111..2222222 100644
--- a/pe-parser-library/include/parser-library/parse.h
+++ b/pe-parser-library/include/parser-library/parse.h
@@ -142,7 +142,6 @@ bool readByte(bounded_buffer *b, std::uint32_t offset, std::uint8_t &out);
 bool readWord(bounded_buffer *b, std::uint32_t offset, std::uint16_t &out);
 bool readDword(bounded_buffer *b, std::uint32_t offset, std::uint32_t &out);
 bool readQword(bounded_buffer *b, std::uint32_t offset, std::uint64_t &out);
-bool readChar16(bounded_buffer *b, std::uint32_t offset, char16_t &out);
 
 bounded_buffer *readFileToFileBuffer(const char *filePath);
 bounded_buffer *
diff --git a/pe-parser-library/include/parser-library/to_string.h b/pe-parser-library/include/parser-library/to_string.h
index 1111111..2222222 100644
--- a/pe-parser-library/include/parser-library/to_string.h
+++ b/pe-parser-library/include/parser-library/to_string.h
@@ -1,15 +1,7 @@
 #pragma once
 
-#include <string>
 #include <sstream>
 
-#ifdef USE_ICU4C
-#include <unicode/unistr.h>
-typedef std::basic_string<UChar> UCharString;
-#else
-typedef std::u16string UCharString;
-#endif
-
 namespace peparse {
 template <class T>
 static std::string to_string(T t, std::ios_base &(*f)(std::ios_base &) ) {
@@ -17,6 +9,4 @@ static std::string to_string(T t, std::ios_base &(*f)(std::ios_base &) ) {
   oss << f << t;
   return oss.str();
 }
-
-std::string from_utf16(const UCharString &u);
 } // namespace peparse
diff --git a/pe-parser-library/src/buffer.cpp b/pe-parser-library/src/buffer.cpp
index 1111111..2222222 100644
--- a/pe-parser-library/src/buffer.cpp
+++ b/pe-parser-library/src/buffer.cpp
@@ -164,31 +164,6 @@ bool readQword(bounded_buffer *b, std::uint32_t offset, std::uint64_t &out) {
   return true;
 }
 
-bool readChar16(bounded_buffer *b, std::uint32_t offset, char16_t &out) {
-  if (b == nullptr) {
-    PE_ERR(PEERR_BUFFER);
-    return false;
-  }
-
-  if (offset + 1 >= b->bufLen) {
-    PE_ERR(PEERR_ADDRESS);
-    return false;
-  }
-
-  char16_t *tmp = nullptr;
-  if (b->swapBytes) {
-    std::uint8_t tmpBuf[2];
-    tmpBuf[0] = *(b->buf + offset + 1);
-    tmpBuf[1] = *(b->buf + offset);
-    tmp = reinterpret_cast<char16_t *>(tmpBuf);
-  } else {
-    tmp = reinterpret_cast<char16_t *>(b->buf + offset);
-  }
-  out = *tmp;
-
-  return true;
-}
-
 bounded_buffer *readFileToFileBuffer(const char *filePath) {
 #ifdef _WIN32
   HANDLE h = CreateFileA(filePath,
diff --git a/pe-parser-library/src/parse.cpp b/pe-parser-library/src/parse.cpp
index 1111111..2222222 100644
--- a/pe-parser-library/src/parse.cpp
+++ b/pe-parser-library/src/parse.cpp
@@ -256,23 +256,19 @@ void IterRsrc(parsed_pe *pe, iterRsrc cb, void *cbd) {
 }
 
 bool parse_resource_id(bounded_buffer *data, std::uint32_t id, std::string &result) {
+  std::uint8_t c;
   std::uint16_t len;
+
   if (!readWord(data, id, len)) {
     return false;
   }
   id += 2;
-
-  std::uint32_t rawSize = len * 2U;
-  UCharString rawString;
-  for (std::uint32_t i = 0; i < rawSize; i += 2) {
-    char16_t c;
-    if (!readChar16(data, id + i, c)) {
+  for (std::uint32_t i = 0; i < len * 2U; i++) {
+    if (!readByte(data, id + i, c)) {
       return false;
     }
-    rawString.push_back(c);
+    result.push_back(static_cast<char>(c));
   }
-
-  result = from_utf16(rawString);
   return true;
 }
 
